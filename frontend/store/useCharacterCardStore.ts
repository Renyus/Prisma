// frontend/store/useCharacterCardStore.ts
import { create } from "zustand";
import { nanoid } from "nanoid";
import { CharacterService } from "@/services/CharacterService";
// import type { CharacterCard } from "@/services/CharacterService"; // Old type
import type { Character, CharacterCreate, CharacterUpdate, PromptInjectionConfig } from "@/types/character"; // New types

interface CharacterStoreState {
  characters: Character[]; // Renamed from characterCards
  currentCharacterId: string | null; // Renamed from currentCardId
  isLoading: boolean;
  error: string | null;

  // actions
  fetchCharacters: () => Promise<void>; // Renamed
  addCharacter: (partial?: Partial<CharacterCreate>) => Promise<string>; // Renamed
  addCharacterFromTavernJson: (data: any, filename?: string) => Promise<string>; // Renamed
  updateCharacter: (id: string, patch: CharacterUpdate) => Promise<void>; // Renamed
  deleteCharacter: (id: string) => Promise<void>; // Renamed
  setCurrentCharacter: (id: string | null) => void; // Renamed
}

export const useCharacterCardStore = create<CharacterStoreState>((set, get) => ({
  characters: [],
  currentCharacterId: null,
  isLoading: false,
  error: null,

  fetchCharacters: async () => {
    set({ isLoading: true, error: null });
    try {
      const fetchedCharacters = await CharacterService.getAll();
      const currentId = get().currentCharacterId;
      
      set({ 
        characters: fetchedCharacters, 
        currentCharacterId: currentId || (fetchedCharacters.length > 0 ? fetchedCharacters[0].id : null) 
      });
    } catch (e: any) {
      console.error(e);
      set({ error: e.message });
    } finally {
      set({ isLoading: false });
    }
  },

  addCharacter: async (partial = {}) => {
    // Construct new character based on new CharacterCreate schema
    const newCharacter: CharacterCreate = {
      name: partial.name || "新角色",
      description: partial.description ?? "",
      persona: partial.persona ?? "",
      scenario: partial.scenario ?? "",
      first_message: partial.first_message ?? "", // Renamed
      system_prompt_override: partial.system_prompt_override ?? null, // New field, was system_prompt
      prompt_config: partial.prompt_config ?? [], // New field
      model_config_override: partial.model_config_override ?? null, // New field
      creator: partial.creator ?? null,
      tags: partial.tags ?? [],
      version: partial.version ?? "1.0.0",
      avatar_url: partial.avatar_url ?? null, // New field
      background_url: partial.background_url ?? null, // New field
    };

    const oldCharacters = get().characters;
    // Optimistic update
    // Note: the `id` will be generated by the backend, so we don't have it yet for optimistic update
    // For now, let's wait for the backend response to add to the list
    set({ isLoading: true }); // Temporarily set loading to prevent UI issues before ID is known
    try {
      const createdCharacter = await CharacterService.create(newCharacter);
      const updatedCharacters = [createdCharacter, ...oldCharacters];
      set({ 
        characters: updatedCharacters, 
        currentCharacterId: createdCharacter.id,
        isLoading: false,
        error: null,
      });
      return createdCharacter.id;
    } catch (e: any) {
      console.error(e);
      set({ characters: oldCharacters, error: "创建角色失败", isLoading: false }); // Revert on error
      throw e; // Re-throw for component to catch
    }
  },

  addCharacterFromTavernJson: async (data: any, filename?: string) => {
    // This function needs significant mapping from Tavern JSON to the new CharacterCreate schema.
    // For simplicity, we'll map common fields. Advanced prompt_config will not be mapped here directly.
    const mappedTags: string[] =
      Array.isArray(data.tags)
        ? data.tags
        : typeof data.tags === "string"
        ? data.tags.split(",").map((t: string) => t.trim()).filter(Boolean)
        : [];

    const tavernSystemPrompt = data.system_prompt || "";
    // If tavernSystemPrompt exists, create a basic PromptInjectionConfig for it
    const promptConfig: PromptInjectionConfig[] = tavernSystemPrompt ? [{
      id: nanoid(),
      role: "system",
      content: tavernSystemPrompt,
      position: "absolute",
      depth: 0,
      enabled: true,
      name: "Tavern System Prompt"
    }] : [];


    const newCharacter: CharacterCreate = {
      name: data.name || filename || "未命名角色",
      description: data.description || "",
      persona: data.persona || data.personality || "",
      scenario: data.scenario || "",
      first_message: data.first_mes || data.firstMes || "", // Mapping old first_mes
      system_prompt_override: null, // Let prompt_config handle this for now
      prompt_config: promptConfig, // Mapped from Tavern system_prompt
      model_config_override: null, // No direct mapping from Tavern JSON for this yet
      creator: data.creator_notes || null, // Re-purpose creator_notes if needed
      tags: mappedTags,
      version: data.version ?? "1.0.0",
      avatar_url: data.avatar || null, // Assuming 'avatar' field in Tavern JSON
      background_url: null,
    };

    const oldCharacters = get().characters;
    set({ isLoading: true });
    try {
      const createdCharacter = await CharacterService.create(newCharacter);
      const updatedCharacters = [createdCharacter, ...oldCharacters];
      set({ 
        characters: updatedCharacters, 
        currentCharacterId: createdCharacter.id,
        isLoading: false,
        error: null,
      });
      return createdCharacter.id;
    } catch (e: any) {
      console.error(e);
      set({ characters: oldCharacters, error: "导入角色失败", isLoading: false });
      throw e;
    }
  },

  updateCharacter: async (id, patch) => {
    const oldCharacters = get().characters;
    const newCharacters = oldCharacters.map((c) =>
      c.id === id ? { ...c, ...patch } : c // Patching directly will work with CharacterUpdate
    );
    set({ characters: newCharacters }); // Optimistic update

    try {
      await CharacterService.update(id, patch);
    } catch (e: any) {
      console.error(e);
      set({ characters: oldCharacters, error: "更新角色失败" }); // Revert on error
      throw e;
    }
  },

  deleteCharacter: async (id) => {
    const oldCharacters = get().characters;
    const newCharacters = oldCharacters.filter((c) => c.id !== id);
    let currentId = get().currentCharacterId;

    if (currentId === id) {
      currentId = newCharacters[0]?.id ?? null;
    }

    set({ characters: newCharacters, currentCharacterId: currentId }); // Optimistic update

    try {
      await CharacterService.delete(id);
    } catch (e: any) {
      console.error(e);
      set({ characters: oldCharacters, error: "删除角色失败" }); // Revert on error
      throw e;
    }
  },

  setCurrentCharacter: (id) => {
    set({ currentCharacterId: id });
  },
}));